@startuml RBAC Architecture
title RBAC (Role-Based Access Control) Architecture

package "User Service" {
  [User Repository] as UserRepo
  [User Service Layer] as UserSvc
  [User HTTP Handler] as UserHandler
  [User gRPC Server] as UserGRPC
}

package "Auth Service" {
  [Role Repository] as RoleRepo
  [Permission Repository] as PermRepo
  [RBAC Service] as RBACService
  [Auth Middleware] as AuthMW
  [Permission Checker] as PermCheck
}

package "API Gateway" {
  [Gateway Router] as Router
  [Auth Filter] as AuthFilter
  [Permission Filter] as PermFilter
}

database "MongoDB" {
  collections "users" as UsersDB
  collections "roles" as RolesDB
  collections "permissions" as PermsDB
  collections "user_roles" as UserRolesDB
  collections "role_permissions" as RolePermsDB
}

actor "User" as User
actor "Admin" as Admin

' Data Model Relationships
note right of RolesDB
  **Role**
  - id: ObjectId
  - name: string (e.g., "admin", "user", "manager")
  - tenant_id: string
  - description: string
  - is_system: boolean
  - created_at: timestamp
end note

note right of PermsDB
  **Permission**
  - id: ObjectId
  - resource: string (e.g., "users", "orders")
  - action: string (e.g., "read", "write", "delete")
  - tenant_id: string
  - description: string
  - created_at: timestamp
end note

note right of UserRolesDB
  **UserRole (Many-to-Many)**
  - user_id: string
  - role_id: string
  - tenant_id: string
  - assigned_by: string
  - assigned_at: timestamp
end note

note right of RolePermsDB
  **RolePermission (Many-to-Many)**
  - role_id: string
  - permission_id: string
  - tenant_id: string
  - created_at: timestamp
end note

' Request Flow
User --> Router: HTTP Request\n+ JWT Token
Router --> AuthFilter: Validate Token
AuthFilter --> AuthMW: Extract User Claims
AuthMW --> PermFilter: Check Permission
PermFilter --> PermCheck: HasPermission(user_id, resource, action)

PermCheck --> RBACService: GetUserPermissions(user_id)
RBACService --> UserRolesDB: FindUserRoles(user_id)
UserRolesDB --> RBACService: [role_ids]
RBACService --> RolePermsDB: FindRolePermissions(role_ids)
RolePermsDB --> RBACService: [permission_ids]
RBACService --> PermsDB: FindPermissions(permission_ids)
PermsDB --> RBACService: [permissions]

RBACService --> PermCheck: UserPermissions
PermCheck --> PermFilter: Authorized/Denied

PermFilter --> UserHandler: Forward Request (if authorized)
UserHandler --> UserSvc: Business Logic
UserSvc --> UserRepo: Data Access
UserRepo --> UsersDB: Query
UsersDB --> UserRepo: Result
UserRepo --> UserSvc: User Data
UserSvc --> UserHandler: Response
UserHandler --> Router: HTTP Response
Router --> User: Result

' Admin Role Management
Admin --> Router: POST /roles\n{name, permissions}
Router --> RBACService: CreateRole()
RBACService --> RolesDB: Insert Role
RBACService --> RolePermsDB: Insert Role Permissions

Admin --> Router: POST /users/:id/roles\n{role_id}
Router --> RBACService: AssignUserRole()
RBACService --> UserRolesDB: Insert User Role

' Permission Hierarchy
note bottom of RBACService
  **Permission Evaluation**
  1. Extract user_id from JWT
  2. Query user_roles for user
  3. Query role_permissions for each role
  4. Aggregate all permissions
  5. Check if requested permission exists
  6. Consider permission hierarchy (admin > manager > user)
  7. Apply tenant isolation
  
  **Common Roles**
  - super_admin: All permissions across all tenants
  - tenant_admin: All permissions within tenant
  - manager: Read/write permissions for specific resources
  - user: Read permissions only
  
  **Common Permissions**
  - users:read, users:write, users:delete
  - roles:read, roles:write, roles:delete
  - orders:read, orders:write, orders:delete
end note

@enduml
