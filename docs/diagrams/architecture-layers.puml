@startuml Architecture Layers - Clean Architecture
title Kiến Trúc Phân Lớp - Clean Architecture Pattern

' Define layer styles
skinparam rectangle {
    BackgroundColor<<external>> LightBlue
    BackgroundColor<<adapter>> LightGreen
    BackgroundColor<<usecase>> LightYellow
    BackgroundColor<<entity>> LightCoral
    BorderColor Black
    roundCorner 15
}

' Outer Layer - External Interfaces
rectangle "External Interfaces Layer\n(Frameworks & Drivers)" <<external>> {
    rectangle "HTTP API (Gin)" as HTTP {
        component "REST Endpoints"
        component "Middleware"
        component "Request/Response"
    }
    
    rectangle "gRPC API" as GRPC {
        component "Proto Definitions"
        component "gRPC Handlers"
        component "Interceptors"
    }
    
    rectangle "Database (MongoDB)" as MongoDB {
        component "Connection Pool"
        component "Query Execution"
        component "Indexes"
    }
    
    rectangle "Cache (Redis)" as Redis {
        component "Cache Client"
        component "Key Management"
        component "TTL Management"
    }
    
    rectangle "External Services" as ExtSvc {
        component "Tenant Service Client"
        component "Notification Client"
        component "Auth Service Client"
    }
    
    rectangle "Observability" as Observability {
        component "Logger (Zap)"
        component "Metrics (Prometheus)"
        component "Tracing (OpenTelemetry)"
    }
}

' Interface Adapters Layer
rectangle "Interface Adapters Layer\n(Controllers & Presenters)" <<adapter>> {
    rectangle "HTTP Handlers" as Handlers {
        component "UserHandler" as UH1 {
            + CreateUser(c *gin.Context)
            + GetUser(c *gin.Context)
            + ListUsers(c *gin.Context)
            + UpdateUser(c *gin.Context)
            + DeleteUser(c *gin.Context)
        }
        component "PreferencesHandler"
        component "HealthCheckHandler"
    }
    
    rectangle "gRPC Handlers" as GRPCHandlers {
        component "UserServiceServer" {
            + CreateUser(ctx, req) (*User, error)
            + GetUser(ctx, req) (*User, error)
            + ListUsers(ctx, req) (*UserList, error)
        }
    }
    
    rectangle "Repositories" as Repos {
        component "UserRepository" as UR1 {
            + Create(ctx, user) error
            + FindByID(ctx, id, tenantID) (*User, error)
            + FindByEmail(ctx, email, tenantID) (*User, error)
            + List(ctx, tenantID, page, size) ([]*User, int64, error)
            + Search(ctx, tenantID, query, page, size) ([]*User, int64, error)
            + Update(ctx, user) error
            + Delete(ctx, id, tenantID) error
        }
        component "PreferencesRepository"
        component "AuditRepository"
    }
    
    rectangle "DTOs" as DTOs {
        component "CreateUserRequest"
        component "UpdateUserRequest"
        component "UserResponse"
        component "ListUsersResponse"
    }
}

' Application Business Rules Layer
rectangle "Application Business Rules Layer\n(Use Cases)" <<usecase>> {
    rectangle "Services" as Services {
        component "UserService" as US1 {
            + CreateUser(ctx, req) (*User, error)
            + GetUser(ctx, id, tenantID) (*User, error)
            + ListUsers(ctx, tenantID, page, size) ([]*User, int64, error)
            + SearchUsers(ctx, tenantID, query, page, size) ([]*User, int64, error)
            + UpdateUser(ctx, id, tenantID, req) (*User, error)
            + DeleteUser(ctx, id, tenantID) error
            + ExportUserData(ctx, userID, tenantID) (*Export, error)
            --
            - validateInput(req) error
            - checkDuplicates(email, tenantID) error
            - sanitizeInput(data) data
            - logAudit(action, userID, changes)
        }
        
        component "ValidationService" {
            + ValidateEmail(email) error
            + ValidateName(name, field) error
            + ValidatePhone(phone) error
            + ValidateTenantID(tenantID) error
            + SanitizeString(s) string
            + SanitizeName(name) string
        }
        
        component "AuditService" {
            + LogOperation(ctx, op) error
            + GetAuditTrail(ctx, userID) ([]*AuditLog, error)
        }
    }
    
    rectangle "Interfaces" as Interfaces {
        interface "IUserRepository" {
            + Create(ctx, user) error
            + FindByID(ctx, id, tenantID) (*User, error)
            + Update(ctx, user) error
            + Delete(ctx, id, tenantID) error
        }
        
        interface "IPreferencesRepository" {
            + Create(ctx, prefs) error
            + FindByUserID(ctx, userID) (*Prefs, error)
        }
        
        interface "ILogger" {
            + Info(msg, fields...)
            + Error(msg, fields...)
        }
    }
}

' Enterprise Business Rules Layer (Core)
rectangle "Enterprise Business Rules Layer\n(Entities)" <<entity>> {
    rectangle "Domain Entities" as Entities {
        component "User Entity" as User {
            - ID : ObjectID
            - Email : string
            - TenantID : string
            - FirstName : string
            - LastName : string
            - Phone : string
            - AvatarURL : string
            - IsActive : bool
            - CreatedAt : time.Time
            - UpdatedAt : time.Time
            --
            + Validate() error
            + GetFullName() string
            + IsDeleted() bool
            + Anonymize()
        }
        
        component "UserPreferences Entity" {
            - ID : ObjectID
            - UserID : string
            - TenantID : string
            - Language : string
            - Timezone : string
            - Theme : string
            - Settings : map[string]interface{}
            --
            + GetSetting(key) interface{}
            + SetSetting(key, value)
        }
        
        component "AuditLog Entity" {
            - ID : ObjectID
            - UserID : string
            - TenantID : string
            - Action : string
            - Changes : map[string]interface{}
            - Timestamp : time.Time
        }
    }
    
    rectangle "Business Rules" as Rules {
        component "Email must be unique per tenant"
        component "Tenant ID is immutable"
        component "Soft delete preserves data"
        component "Audit trail for all operations"
        component "GDPR compliance rules"
    }
}

' Dependency Arrows (pointing inward)
HTTP --> Handlers : uses
GRPC --> GRPCHandlers : uses
Handlers --> Services : calls
GRPCHandlers --> Services : calls
Handlers --> DTOs : uses
Services --> Interfaces : depends on
Repos --> Entities : operates on
Services --> Entities : operates on
Repos .|> Interfaces : implements
MongoDB --> Repos : used by
Redis --> Repos : used by
Services --> Rules : enforces

' Notes for each layer
note right of HTTP
    **External Layer**
    - Framework-specific code
    - I/O operations
    - External dependencies
    - Infrastructure concerns
    
    **Dependency Direction**: Inward only
    **Changes**: Most frequent
end note

note right of Handlers
    **Interface Adapters**
    - Convert external format to internal
    - Handle HTTP/gRPC protocols
    - Format responses
    - Error handling
    
    **No business logic here**
end note

note right of Services
    **Application Business Rules**
    - Orchestrate use cases
    - Coordinate repositories
    - Enforce business rules
    - Transaction boundaries
    
    **Independent of frameworks**
end note

note right of Entities
    **Enterprise Business Rules**
    - Core domain models
    - Business entities
    - Fundamental rules
    - No external dependencies
    
    **Most stable layer**
end note

' Dependency Rule Visualization
note bottom of Entities
    **The Dependency Rule**
    
    ┌─────────────────────────────────────┐
    │  External Interfaces                │
    │  ┌───────────────────────────────┐  │
    │  │  Interface Adapters           │  │
    │  │  ┌─────────────────────────┐  │  │
    │  │  │  Use Cases              │  │  │
    │  │  │  ┌───────────────────┐  │  │  │
    │  │  │  │  Entities         │  │  │  │
    │  │  │  │                   │  │  │  │
    │  │  │  └───────────────────┘  │  │  │
    │  │  │                         │  │  │
    │  │  └─────────────────────────┘  │  │
    │  │                                │  │
    │  └───────────────────────────────┘  │
    │                                      │
    └─────────────────────────────────────┘
    
    Dependencies point INWARD only:
    External → Adapters → Use Cases → Entities
    
    Inner layers know nothing about outer layers
end note

' Data Flow
note top of HTTP
    **Request Flow**
    
    1. HTTP Request arrives
       ↓
    2. Handler parses & validates format
       ↓
    3. Service applies business rules
       ↓
    4. Repository accesses data
       ↓
    5. Entity contains business data
       ↓
    6. Response flows back up
    
    **Each layer adds value**
end note

' Benefits
legend right
    **Clean Architecture Benefits**
    
    ✓ **Independent of Frameworks**
      Can change Gin to Echo without affecting business logic
    
    ✓ **Testable**
      Business logic can be tested without UI, DB, or servers
    
    ✓ **Independent of UI**
      Can have HTTP, gRPC, CLI without changing use cases
    
    ✓ **Independent of Database**
      Can switch from MongoDB to PostgreSQL
    
    ✓ **Independent of External Services**
      Business rules don't depend on external APIs
    
    **Key Principle**: Dependency Inversion
    High-level modules do not depend on low-level modules
    Both depend on abstractions (interfaces)
endlegend

' Example of Dependency Inversion
note left of Interfaces
    **Dependency Inversion Example**
    
    Service doesn't depend on concrete Repository
    Service depends on IUserRepository interface
    Repository implements IUserRepository interface
    
    This allows:
    - Easy mocking for tests
    - Swapping implementations
    - Multiple implementations (e.g., SQL, NoSQL)
    
    ```go
    type UserService struct {
        repo IUserRepository  // interface, not concrete
    }
    
    func NewUserService(repo IUserRepository) *UserService {
        return &UserService{repo: repo}
    }
    ```
end note

@enduml
