@startuml Data Flow - User Service
title Sơ Đồ Luồng Dữ Liệu - User Service Operations

' Create User Flow
package "Create User Flow" {
    participant "Client" as Client1
    participant "API Gateway" as Gateway1
    participant "Tenancy MW" as Tenancy1
    participant "User Handler" as Handler1
    participant "User Service" as Service1
    participant "Validation" as Validation1
    participant "User Repository" as Repo1
    participant "Audit Repository" as Audit1
    participant "MongoDB" as DB1
    participant "Redis Cache" as Cache1
    
    Client1 -> Gateway1 : POST /api/v1/users\n+ X-Tenant-ID header\n+ User data (JSON)
    activate Gateway1
    Gateway1 -> Gateway1 : Validate JWT token
    Gateway1 -> Tenancy1 : Forward request
    activate Tenancy1
    
    Tenancy1 -> Tenancy1 : Extract X-Tenant-ID
    Tenancy1 -> Tenancy1 : Validate tenant format
    Tenancy1 -> Handler1 : Request + Tenant ID
    activate Handler1
    
    Handler1 -> Handler1 : Bind JSON to\nCreateUserRequest
    Handler1 -> Service1 : CreateUser(ctx, request)
    activate Service1
    
    Service1 -> Validation1 : ValidateEmail(email)
    activate Validation1
    Validation1 --> Service1 : Valid/Error
    deactivate Validation1
    
    Service1 -> Validation1 : ValidateName(firstName)
    activate Validation1
    Validation1 --> Service1 : Valid/Error
    deactivate Validation1
    
    Service1 -> Validation1 : SanitizeInput(data)
    activate Validation1
    Validation1 --> Service1 : Sanitized data
    deactivate Validation1
    
    Service1 -> Repo1 : FindByEmail(email, tenantID)
    activate Repo1
    Repo1 -> DB1 : Query: {email, tenant_id}
    activate DB1
    DB1 --> Repo1 : User/null
    deactivate DB1
    Repo1 --> Service1 : null (user not exists)
    deactivate Repo1
    
    Service1 -> Service1 : Create User entity\nSet timestamps
    
    Service1 -> Repo1 : Create(ctx, user)
    activate Repo1
    Repo1 -> DB1 : Insert into users collection
    activate DB1
    DB1 --> Repo1 : Inserted with ID
    deactivate DB1
    Repo1 --> Service1 : User with ID
    deactivate Repo1
    
    Service1 -> Audit1 : LogAudit(user.created, userID)
    activate Audit1
    Audit1 -> DB1 : Insert audit log
    activate DB1
    DB1 --> Audit1 : Success
    deactivate DB1
    deactivate Audit1
    
    Service1 --> Handler1 : Created User
    deactivate Service1
    
    Handler1 -> Handler1 : Convert to UserResponse DTO
    Handler1 --> Tenancy1 : 201 Created + UserResponse
    deactivate Handler1
    
    Tenancy1 --> Gateway1 : Response
    deactivate Tenancy1
    
    Gateway1 --> Client1 : 201 Created\n{ "data": { user } }
    deactivate Gateway1
}

|||

' Get User Flow (with cache)
package "Get User Flow (with Cache)" {
    participant "Client" as Client2
    participant "Tenancy MW" as Tenancy2
    participant "User Handler" as Handler2
    participant "User Service" as Service2
    participant "User Repository" as Repo2
    participant "Redis Cache" as Cache2
    participant "MongoDB" as DB2
    
    Client2 -> Tenancy2 : GET /api/v1/users/:id\n+ X-Tenant-ID header
    activate Tenancy2
    Tenancy2 -> Handler2 : Request + Tenant ID
    activate Handler2
    Handler2 -> Service2 : GetUser(ctx, userID, tenantID)
    activate Service2
    
    Service2 -> Repo2 : FindByID(userID, tenantID)
    activate Repo2
    
    ' Cache Hit Path
    Repo2 -> Cache2 : GET user:{userID}:{tenantID}
    activate Cache2
    
    alt Cache Hit
        Cache2 --> Repo2 : Cached User
        Repo2 --> Service2 : User from cache
        note right: Fast path: ~5ms
    else Cache Miss
        Cache2 --> Repo2 : null
        deactivate Cache2
        
        Repo2 -> DB2 : Find: {_id, tenant_id}
        activate DB2
        DB2 --> Repo2 : User document
        deactivate DB2
        
        Repo2 -> Cache2 : SET user:{userID}:{tenantID}\nTTL: 15 min
        activate Cache2
        Cache2 --> Repo2 : OK
        deactivate Cache2
        
        Repo2 --> Service2 : User from DB
        note right: Slow path: ~20ms
    end
    
    deactivate Repo2
    Service2 --> Handler2 : User
    deactivate Service2
    Handler2 -> Handler2 : Convert to UserResponse
    Handler2 --> Tenancy2 : 200 OK + UserResponse
    deactivate Handler2
    Tenancy2 --> Client2 : Response
    deactivate Tenancy2
}

|||

' Search Users Flow
package "Search Users Flow" {
    participant "Client" as Client3
    participant "User Handler" as Handler3
    participant "User Service" as Service3
    participant "User Repository" as Repo3
    participant "MongoDB" as DB3
    
    Client3 -> Handler3 : GET /api/v1/users/search\n?q=john&page=1&page_size=20\n+ X-Tenant-ID header
    activate Handler3
    
    Handler3 -> Service3 : SearchUsers(ctx, tenantID, query, page, size)
    activate Service3
    
    Service3 -> Service3 : Validate query
    Service3 -> Service3 : Sanitize query\n(prevent injection)
    
    Service3 -> Repo3 : Search(tenantID, query, page, size)
    activate Repo3
    
    Repo3 -> DB3 : Find with $text search:\n{ tenant_id: "X", $text: { $search: "john" } }\nSkip: 0, Limit: 20
    activate DB3
    
    DB3 -> DB3 : Use text index:\n{first_name, last_name, email}
    DB3 -> DB3 : Filter by tenant_id
    DB3 -> DB3 : Apply pagination
    
    DB3 --> Repo3 : Users array + count
    deactivate DB3
    
    Repo3 --> Service3 : Users + total count
    deactivate Repo3
    
    Service3 --> Handler3 : (users, total)
    deactivate Service3
    
    Handler3 -> Handler3 : Convert to ListUsersResponse\n{ users, total, page, page_size }
    Handler3 --> Client3 : 200 OK + ListUsersResponse
    deactivate Handler3
}

|||

' Update User Flow
package "Update User Flow" {
    participant "Client" as Client4
    participant "User Service" as Service4
    participant "Validation" as Validation4
    participant "User Repository" as Repo4
    participant "MongoDB" as DB4
    participant "Redis Cache" as Cache4
    participant "Audit Repository" as Audit4
    
    Client4 -> Service4 : UpdateUser(ctx, userID, tenantID, request)
    activate Service4
    
    Service4 -> Validation4 : Validate update fields
    activate Validation4
    Validation4 -> Validation4 : Validate name\nValidate phone\nSanitize inputs
    Validation4 --> Service4 : Valid/Error
    deactivate Validation4
    
    Service4 -> Repo4 : FindByID(userID, tenantID)
    activate Repo4
    Repo4 -> DB4 : Find existing user
    activate DB4
    DB4 --> Repo4 : Current user
    deactivate DB4
    Repo4 --> Service4 : Current user
    deactivate Repo4
    
    Service4 -> Service4 : Update user fields\nSet updated_at timestamp\nTrack changes
    
    Service4 -> Repo4 : Update(ctx, user)
    activate Repo4
    
    Repo4 -> DB4 : UpdateOne:\n{ _id, tenant_id }\n{ $set: updatedFields }
    activate DB4
    DB4 --> Repo4 : Success
    deactivate DB4
    
    Repo4 -> Cache4 : DELETE user:{userID}:{tenantID}
    activate Cache4
    Cache4 --> Repo4 : Cache invalidated
    deactivate Cache4
    note right: Invalidate cache\nto ensure consistency
    
    Repo4 --> Service4 : Updated user
    deactivate Repo4
    
    Service4 -> Audit4 : LogAudit(user.updated, userID, changes)
    activate Audit4
    Audit4 -> DB4 : Insert audit log\nwith change diff
    activate DB4
    DB4 --> Audit4 : Success
    deactivate DB4
    deactivate Audit4
    
    Service4 --> Client4 : Updated user
    deactivate Service4
}

|||

' Delete User Flow (Soft Delete)
package "Delete User Flow (Soft Delete)" {
    participant "Client" as Client5
    participant "User Service" as Service5
    participant "User Repository" as Repo5
    participant "MongoDB" as DB5
    participant "Redis Cache" as Cache5
    participant "Audit Repository" as Audit5
    
    Client5 -> Service5 : DeleteUser(ctx, userID, tenantID)
    activate Service5
    
    Service5 -> Repo5 : FindByID(userID, tenantID)
    activate Repo5
    Repo5 -> DB5 : Find user
    activate DB5
    DB5 --> Repo5 : User
    deactivate DB5
    Repo5 --> Service5 : User exists
    deactivate Repo5
    
    Service5 -> Repo5 : Delete(ctx, userID, tenantID)
    activate Repo5
    
    Repo5 -> DB5 : UpdateOne (Soft Delete):\n{ _id, tenant_id }\n{ $set: { is_active: false, updated_at: now } }
    activate DB5
    DB5 --> Repo5 : Success
    deactivate DB5
    note right: Soft delete:\nData retained for\naudit & compliance
    
    Repo5 -> Cache5 : DELETE user:{userID}:{tenantID}
    activate Cache5
    Cache5 --> Repo5 : Cache invalidated
    deactivate Cache5
    
    Repo5 --> Service5 : Success
    deactivate Repo5
    
    Service5 -> Audit5 : LogAudit(user.deleted, userID)
    activate Audit5
    Audit5 -> DB5 : Insert audit log
    activate DB5
    DB5 --> Audit5 : Success
    deactivate DB5
    deactivate Audit5
    
    Service5 --> Client5 : Success (204 No Content)
    deactivate Service5
}

' Notes
note over Client1, DB1
    **Create User Flow**
    1. Validate JWT & tenant
    2. Validate & sanitize input
    3. Check for duplicates
    4. Create user entity
    5. Insert to database
    6. Log audit trail
    7. Return created user
end note

note over Client2, DB2
    **Get User Flow**
    1. Check Redis cache first
    2. If cache miss, query MongoDB
    3. Store result in cache
    4. Return user data
    **Performance**: 
    - Cache hit: ~5ms
    - Cache miss: ~20ms
end note

note over Client3, DB3
    **Search Users Flow**
    1. Validate & sanitize query
    2. Use MongoDB text index
    3. Filter by tenant_id
    4. Apply pagination
    5. Return results with total count
end note

note over Client4, Audit4
    **Update User Flow**
    1. Validate update fields
    2. Get current user
    3. Apply updates
    4. Invalidate cache
    5. Log changes to audit
end note

note over Client5, Audit5
    **Delete User Flow**
    1. Verify user exists
    2. Soft delete (set is_active=false)
    3. Invalidate cache
    4. Log deletion to audit
    **Data retained for compliance**
end note

@enduml
